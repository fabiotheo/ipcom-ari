{
  "version": 3,
  "sources": ["../../node_modules/exponential-backoff/src/options.ts", "../../node_modules/exponential-backoff/src/jitter/full/full.jitter.ts", "../../node_modules/exponential-backoff/src/jitter/no/no.jitter.ts", "../../node_modules/exponential-backoff/src/jitter/jitter.factory.ts", "../../node_modules/exponential-backoff/src/delay/delay.base.ts", "../../node_modules/exponential-backoff/src/delay/skip-first/skip-first.delay.ts", "../../node_modules/exponential-backoff/src/delay/always/always.delay.ts", "../../node_modules/exponential-backoff/src/delay/delay.factory.ts", "../../node_modules/exponential-backoff/src/backoff.ts", "../../src/index.ts", "../../src/ari-client/baseClient.ts", "../../src/ari-client/resources/applications.ts", "../../src/ari-client/resources/asterisk.ts", "../../src/ari-client/resources/bridges.ts", "../../src/ari-client/resources/channels.ts", "../../node_modules/uuid/dist/esm/stringify.js", "../../node_modules/uuid/dist/esm/rng.js", "../../node_modules/uuid/dist/esm/native.js", "../../node_modules/uuid/dist/esm/v4.js", "../../src/ari-client/utils.ts", "../../src/ari-client/resources/endpoints.ts", "../../src/ari-client/resources/playbacks.ts", "../../src/ari-client/resources/sounds.ts", "../../src/ari-client/websocketClient.ts", "../../src/ari-client/ariClient.ts"],
  "sourcesContent": [null, null, null, null, null, null, null, null, null, "/**\n * @file Main entry point for the Asterisk REST Interface (ARI) client package\n * @description This file exports all the necessary classes, types and interfaces for interacting with the ARI\n */\n\n/**\n * Main client class for interacting with Asterisk REST Interface\n * @packageDocumentation\n */\nexport { AriClient } from \"./ari-client/ariClient.js\";\n\n/**\n * Resource Classes\n * These classes provide direct access to ARI resources\n */\nexport {\n  Channels,\n  ChannelInstance,\n} from \"./ari-client/resources/channels.js\";\n\nexport { Endpoints } from \"./ari-client/resources/endpoints.js\";\nexport { Applications } from \"./ari-client/resources/applications.js\";\nexport { Sounds } from \"./ari-client/resources/sounds.js\";\nexport {\n  Playbacks,\n  PlaybackInstance,\n} from \"./ari-client/resources/playbacks.js\";\nexport { Asterisk } from \"./ari-client/resources/asterisk.js\";\nexport { Bridges } from \"./ari-client/resources/bridges.js\";\n\n/**\n * Type Definitions\n * These types and interfaces define the shape of data structures used throughout the API\n */\n\n// Configuration Types\nexport type {\n  AriClientConfig,\n  AriApplication,\n} from \"./ari-client/interfaces/index.js\";\n\n// Channel Related Types\nexport type {\n  Channel,\n  ChannelEvent,\n  ChannelPlayback,\n  ChannelVar,\n  ChannelDialplan,\n  OriginateRequest,\n  RecordingOptions,\n  SnoopOptions,\n  ExternalMediaOptions,\n  RTPStats,\n} from \"./ari-client/interfaces/index.js\";\n\n// Playback Related Types\nexport type {\n  Playback,\n  PlaybackEvent,\n  PlaybackOptions,\n  PlaybackControlRequest,\n  PlayMediaRequest,\n} from \"./ari-client/interfaces/index.js\";\n\n// Bridge Related Types\nexport type {\n  Bridge,\n  BridgePlayback,\n  CreateBridgeRequest,\n  RemoveChannelRequest,\n  AddChannelRequest,\n} from \"./ari-client/interfaces/index.js\";\n\n// Endpoint Related Types\nexport type {\n  Endpoint,\n  EndpointDetails,\n} from \"./ari-client/interfaces/index.js\";\n\n// Application Related Types\nexport type {\n  Application,\n  ApplicationDetails,\n} from \"./ari-client/interfaces/index.js\";\n\n// Sound Related Types\nexport type {\n  Sound,\n  SoundListRequest,\n} from \"./ari-client/interfaces/index.js\";\n\n// Asterisk Related Types\nexport type {\n  AsteriskInfo,\n  Module,\n  Logging,\n  Variable,\n  AsteriskPing,\n} from \"./ari-client/interfaces/index.js\";\n\n// WebSocket Related Types\nexport type {\n  WebSocketEvent,\n  WebSocketEventType,\n} from \"./ari-client/interfaces/index.js\";\n", "import axios, {\n  type AxiosInstance,\n  type AxiosRequestConfig,\n  isAxiosError\n} from \"axios\";\n\n/**\n * Custom error class for HTTP-related errors\n */\nclass HTTPError extends Error {\n  constructor(\n      message: string,\n      public readonly status?: number,\n      public readonly method?: string,\n      public readonly url?: string,\n  ) {\n    super(message);\n    this.name = 'HTTPError';\n  }\n}\n\n/**\n * BaseClient handles HTTP communications with the ARI server.\n * Provides methods for making HTTP requests and manages authentication and error handling.\n */\nexport class BaseClient {\n  private readonly client: AxiosInstance;\n\n  /**\n   * Creates a new BaseClient instance.\n   *\n   * @param {string} baseUrl - The base URL for the API\n   * @param {string} username - Username for authentication\n   * @param {string} password - Password for authentication\n   * @param {number} [timeout=5000] - Request timeout in milliseconds\n   * @throws {Error} If the base URL format is invalid\n   */\n  constructor(\n      private readonly baseUrl: string,\n      private readonly username: string,\n      private readonly password: string,\n      timeout = 5000,\n  ) {\n    if (!/^https?:\\/\\/.+/.test(baseUrl)) {\n      throw new Error(\"Invalid base URL. It must start with http:// or https://\");\n    }\n\n    this.client = axios.create({\n      baseURL: baseUrl,\n      auth: { username, password },\n      timeout,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    this.addInterceptors();\n    console.log(`BaseClient initialized for ${baseUrl}`);\n  }\n\n  /**\n   * Gets the base URL of the client.\n   */\n  public getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  /**\n   * Gets the configured credentials.\n   */\n  public getCredentials(): {\n    baseUrl: string;\n    username: string;\n    password: string;\n  } {\n    return {\n      baseUrl: this.baseUrl,\n      username: this.username,\n      password: this.password,\n    };\n  }\n\n  /**\n   * Adds request and response interceptors to the Axios instance.\n   */\n  private addInterceptors(): void {\n    this.client.interceptors.request.use(\n        (config) => {\n          console.log(`[Request] ${config.method?.toUpperCase()} ${config.url}`);\n          return config;\n        },\n        (error: unknown) => {\n          const message = this.getErrorMessage(error);\n          console.error(\"[Request Error]\", message);\n          return Promise.reject(new HTTPError(message));\n        },\n    );\n\n    this.client.interceptors.response.use(\n        (response) => {\n          console.log(`[Response] ${response.status} ${response.config.url}`);\n          return response;\n        },\n        (error: unknown) => {\n          if (isAxiosError(error)) {\n            const status = error.response?.status ?? 0;\n            const method = error.config?.method?.toUpperCase() ?? 'UNKNOWN';\n            const url = error.config?.url ?? 'unknown-url';\n            const message = error.response?.data?.message || error.message || 'Unknown error';\n\n            if (status === 404) {\n              console.warn(`[404] Not Found: ${url}`);\n            } else if (status >= 500) {\n              console.error(`[${status}] Server Error: ${url}`);\n            } else if (status > 0) {\n              console.warn(`[${status}] ${method} ${url}: ${message}`);\n            } else {\n              console.error(`[Network] Request failed: ${message}`);\n            }\n\n            throw new HTTPError(message, status || undefined, method, url);\n          }\n\n          const message = this.getErrorMessage(error);\n          console.error(\"[Unexpected Error]\", message);\n          throw new Error(message);\n        },\n    );\n  }\n\n  /**\n   * Executes a GET request.\n   *\n   * @param path - API endpoint path\n   * @param config - Optional Axios request configuration\n   * @returns Promise with the response data\n   */\n  async get<T>(path: string, config?: AxiosRequestConfig): Promise<T> {\n    try {\n      const response = await this.client.get<T>(path, config);\n      return response.data;\n    } catch (error: unknown) {\n      throw this.handleRequestError(error);\n    }\n  }\n\n  /**\n   * Executes a POST request.\n   *\n   * @param path - API endpoint path\n   * @param data - Request payload\n   * @param config - Optional Axios request configuration\n   * @returns Promise with the response data\n   */\n  async post<T, D = unknown>(\n      path: string,\n      data?: D,\n      config?: AxiosRequestConfig,\n  ): Promise<T> {\n    try {\n      const response = await this.client.post<T>(path, data, config);\n      return response.data;\n    } catch (error: unknown) {\n      throw this.handleRequestError(error);\n    }\n  }\n\n  /**\n   * Executes a PUT request.\n   *\n   * @param path - API endpoint path\n   * @param data - Request payload\n   * @param config - Optional Axios request configuration\n   * @returns Promise with the response data\n   */\n  async put<T, D = unknown>(\n      path: string,\n      data: D,\n      config?: AxiosRequestConfig,\n  ): Promise<T> {\n    try {\n      const response = await this.client.put<T>(path, data, config);\n      return response.data;\n    } catch (error: unknown) {\n      throw this.handleRequestError(error);\n    }\n  }\n\n  /**\n   * Executes a DELETE request.\n   *\n   * @param path - API endpoint path\n   * @param config - Optional Axios request configuration\n   * @returns Promise with the response data\n   */\n  async delete<T>(path: string, config?: AxiosRequestConfig): Promise<T> {\n    try {\n      const response = await this.client.delete<T>(path, config);\n      return response.data;\n    } catch (error: unknown) {\n      throw this.handleRequestError(error);\n    }\n  }\n\n  /**\n   * Handles and formats error messages from various error types.\n   */\n  private getErrorMessage(error: unknown): string {\n    if (isAxiosError(error)) {\n      return error.response?.data?.message || error.message || \"HTTP Error\";\n    }\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return \"An unknown error occurred\";\n  }\n\n  /**\n   * Handles errors from HTTP requests.\n   */\n  private handleRequestError(error: unknown): never {\n    const message = this.getErrorMessage(error);\n    if (isAxiosError(error)) {\n      throw new HTTPError(\n          message,\n          error.response?.status,\n          error.config?.method?.toUpperCase(),\n          error.config?.url\n      );\n    }\n    throw new Error(message);\n  }\n\n  /**\n   * Sets custom headers for the client instance.\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this.client.defaults.headers.common = {\n      ...this.client.defaults.headers.common,\n      ...headers,\n    };\n    console.log(\"Updated client headers\");\n  }\n\n  /**\n   * Gets the current request timeout setting.\n   */\n  getTimeout(): number {\n    return this.client.defaults.timeout || 5000;\n  }\n\n  /**\n   * Updates the request timeout setting.\n   */\n  setTimeout(timeout: number): void {\n    this.client.defaults.timeout = timeout;\n    console.log(`Updated timeout to ${timeout}ms`);\n  }\n}\n", "import type { BaseClient } from \"../baseClient.js\";\nimport type {\n  Application,\n  ApplicationDetails,\n} from \"../interfaces/applications.types.js\";\n\nexport interface ApplicationMessage {\n  event: string;\n  data?: Record<string, any>;\n}\n\nexport class Applications {\n  constructor(private client: BaseClient) {}\n\n  /**\n   * Lists all applications.\n   * \n   * @returns A promise that resolves to an array of Application objects.\n   * @throws {Error} If the API response is not an array.\n   */\n  async list(): Promise<Application[]> {\n    const applications = await this.client.get<unknown>(\"/applications\");\n\n    if (!Array.isArray(applications)) {\n      throw new Error(\"Resposta da API /applications n\u00E3o \u00E9 um array.\");\n    }\n\n    return applications as Application[];\n  }\n\n  /**\n   * Retrieves details of a specific application.\n   * \n   * @param appName - The name of the application to retrieve details for.\n   * @returns A promise that resolves to an ApplicationDetails object.\n   * @throws {Error} If there's an error fetching the application details.\n   */\n  async getDetails(appName: string): Promise<ApplicationDetails> {\n    try {\n      return await this.client.get<ApplicationDetails>(\n        `/applications/${appName}`,\n      );\n    } catch (error) {\n      console.error(`Erro ao obter detalhes do aplicativo ${appName}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Sends a message to a specific application.\n   * \n   * @param appName - The name of the application to send the message to.\n   * @param body - The message to be sent, containing an event and optional data.\n   * @returns A promise that resolves when the message is successfully sent.\n   */\n  async sendMessage(appName: string, body: ApplicationMessage): Promise<void> {\n    await this.client.post<void>(`/applications/${appName}/messages`, body);\n  }\n}\n", "import type { BaseClient } from \"../baseClient.js\";\nimport type {\n  AsteriskInfo,\n  AsteriskPing,\n  Logging,\n  Module,\n  Variable,\n} from \"../interfaces\";\n\nfunction toQueryParams<T>(options: T): string {\n  return new URLSearchParams(\n    Object.entries(options as Record<string, string>)\n      .filter(([, value]) => value !== undefined)\n      .map(([key, value]) => [key, String(value)]),\n  ).toString();\n}\n\nexport class Asterisk {\n  constructor(private client: BaseClient) {}\n\n  async ping(): Promise<AsteriskPing> {\n    return this.client.get<AsteriskPing>(\"/asterisk/ping\");\n  }\n\n  /**\n   * Retrieves information about the Asterisk server.\n   */\n  async get(): Promise<AsteriskInfo> {\n    return this.client.get<AsteriskInfo>(\"/asterisk/info\");\n  }\n\n  /**\n   * Lists all loaded modules in the Asterisk server.\n   */\n  async list(): Promise<Module[]> {\n    return this.client.get<Module[]>(\"/asterisk/modules\");\n  }\n\n  /**\n   * Manages a specific module in the Asterisk server.\n   *\n   * @param moduleName - The name of the module to manage.\n   * @param action - The action to perform on the module: \"load\", \"unload\", or \"reload\".\n   * @returns A promise that resolves when the action is completed successfully.\n   * @throws {Error} Throws an error if the HTTP method or action is invalid.\n   */\n  async manage(\n    moduleName: string,\n    action: \"load\" | \"unload\" | \"reload\",\n  ): Promise<void> {\n    const url = `/asterisk/modules/${moduleName}`;\n    switch (action) {\n      case \"load\":\n        await this.client.post<void>(`${url}?action=load`);\n        break;\n      case \"unload\":\n        await this.client.delete<void>(url);\n        break;\n      case \"reload\":\n        await this.client.put<void>(url, {});\n        break;\n      default:\n        throw new Error(`A\u00E7\u00E3o inv\u00E1lida: ${action}`);\n    }\n  }\n\n  /**\n   * Retrieves all configured logging channels.\n   */\n  async listLoggingChannels(): Promise<Logging[]> {\n    return this.client.get<Logging[]>(\"/asterisk/logging\");\n  }\n\n  /**\n   * Adds or removes a log channel in the Asterisk server.\n   */\n  async manageLogChannel(\n    logChannelName: string,\n    action: \"add\" | \"remove\",\n    configuration?: { type?: string; configuration?: string },\n  ): Promise<void> {\n    const queryParams = toQueryParams(configuration || {});\n    return this.client.post<void>(\n      `/asterisk/logging/${logChannelName}?action=${encodeURIComponent(action)}&${queryParams}`,\n    );\n  }\n\n  /**\n   * Retrieves the value of a global variable.\n   */\n  async getGlobalVariable(variableName: string): Promise<Variable> {\n    return this.client.get<Variable>(\n      `/asterisk/variables?variable=${encodeURIComponent(variableName)}`,\n    );\n  }\n\n  /**\n   * Sets a global variable.\n   */\n  async setGlobalVariable(variableName: string, value: string): Promise<void> {\n    return this.client.post<void>(\n      `/asterisk/variables?variable=${encodeURIComponent(variableName)}&value=${encodeURIComponent(value)}`,\n    );\n  }\n}\n", "import type { BaseClient } from \"../baseClient.js\";\nimport type {\n  AddChannelRequest,\n  Bridge,\n  BridgePlayback,\n  CreateBridgeRequest,\n  PlayMediaRequest,\n  RemoveChannelRequest,\n} from \"../interfaces/bridges.types.js\";\n\nexport class Bridges {\n  constructor(private client: BaseClient) {}\n\n  /**\n   * Lists all active bridges.\n   */\n  async list(): Promise<Bridge[]> {\n    return this.client.get<Bridge[]>(\"/bridges\");\n  }\n\n  /**\n   * Creates a new bridge.\n   */\n  async createBridge(request: CreateBridgeRequest): Promise<Bridge> {\n    return this.client.post<Bridge>(\"/bridges\", request);\n  }\n\n  /**\n   * Retrieves details of a specific bridge.\n   */\n  async getDetails(bridgeId: string): Promise<Bridge> {\n    return this.client.get<Bridge>(`/bridges/${bridgeId}`);\n  }\n\n  /**\n   * Destroys (deletes) a specific bridge.\n   */\n  async destroy(bridgeId: string): Promise<void> {\n    return this.client.delete<void>(`/bridges/${bridgeId}`);\n  }\n\n  /**\n   * Adds a channel or multiple channels to a bridge.\n   */\n  async addChannels(\n    bridgeId: string,\n    request: AddChannelRequest,\n  ): Promise<void> {\n    const queryParams = new URLSearchParams({\n      channel: Array.isArray(request.channel)\n        ? request.channel.join(\",\")\n        : request.channel,\n      ...(request.role && { role: request.role }),\n    }).toString();\n\n    await this.client.post<void>(\n      `/bridges/${bridgeId}/addChannel?${queryParams}`,\n    );\n  }\n\n  /**\n   * Removes a channel or multiple channels from a bridge.\n   */\n  async removeChannels(\n    bridgeId: string,\n    request: RemoveChannelRequest,\n  ): Promise<void> {\n    const queryParams = new URLSearchParams({\n      channel: Array.isArray(request.channel)\n        ? request.channel.join(\",\")\n        : request.channel,\n    }).toString();\n\n    await this.client.post<void>(\n      `/bridges/${bridgeId}/removeChannel?${queryParams}`,\n    );\n  }\n\n  /**\n   * Plays media to a bridge.\n   */\n  async playMedia(\n    bridgeId: string,\n    request: PlayMediaRequest,\n  ): Promise<BridgePlayback> {\n    const queryParams = new URLSearchParams({\n      ...(request.lang && { lang: request.lang }),\n      ...(request.offsetms && { offsetms: request.offsetms.toString() }),\n      ...(request.skipms && { skipms: request.skipms.toString() }),\n      ...(request.playbackId && { playbackId: request.playbackId }),\n    }).toString();\n\n    return this.client.post<BridgePlayback>(\n      `/bridges/${bridgeId}/play?${queryParams}`,\n      { media: request.media },\n    );\n  }\n\n  /**\n   * Stops media playback on a bridge.\n   */\n  async stopPlayback(bridgeId: string, playbackId: string): Promise<void> {\n    await this.client.delete<void>(`/bridges/${bridgeId}/play/${playbackId}`);\n  }\n\n  /**\n   * Sets the video source for a bridge.\n   */\n  async setVideoSource(bridgeId: string, channelId: string): Promise<void> {\n    await this.client.post<void>(\n      `/bridges/${bridgeId}/videoSource?channelId=${encodeURIComponent(channelId)}`,\n    );\n  }\n\n  /**\n   * Clears the video source for a bridge.\n   */\n  async clearVideoSource(bridgeId: string): Promise<void> {\n    await this.client.delete<void>(`/bridges/${bridgeId}/videoSource`);\n  }\n}\n", "import { EventEmitter } from \"events\";\nimport { isAxiosError } from \"axios\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport type { AriClient } from \"../ariClient\";\nimport type { BaseClient } from \"../baseClient.js\";\nimport type {\n  Channel,\n  ChannelPlayback,\n  ChannelVar,\n  ExternalMediaOptions,\n  OriginateRequest,\n  PlaybackOptions,\n  RTPStats,\n  RecordingOptions,\n  SnoopOptions,\n  WebSocketEvent,\n} from \"../interfaces\";\nimport { toQueryParams } from \"../utils\";\nimport type { PlaybackInstance } from \"./playbacks\";\n\n/**\n * Utility function to extract error message\n */\nconst getErrorMessage = (error: unknown): string => {\n  if (isAxiosError(error)) {\n    return (\n      error.response?.data?.message ||\n      error.message ||\n      \"An axios error occurred\"\n    );\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return \"An unknown error occurred\";\n};\n\n/**\n * Represents an instance of a communication channel managed by the AriClient.\n */\nexport class ChannelInstance {\n  private readonly eventEmitter = new EventEmitter();\n  private channelData: Channel | null = null;\n  public readonly id: string;\n\n  constructor(\n    private readonly client: AriClient,\n    private readonly baseClient: BaseClient,\n    channelId?: string,\n  ) {\n    this.id = channelId || `channel-${Date.now()}`;\n    console.log(`Channel instance initialized with ID: ${this.id}`);\n  }\n\n  /**\n   * Registers an event listener for specific channel events\n   */\n  on<T extends WebSocketEvent[\"type\"]>(\n    event: T,\n    listener: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!event) {\n      throw new Error(\"Event type is required\");\n    }\n\n    const wrappedListener = (data: WebSocketEvent) => {\n      if (\"channel\" in data && data.channel?.id === this.id) {\n        listener(data as Extract<WebSocketEvent, { type: T }>);\n      }\n    };\n    this.eventEmitter.on(event, wrappedListener);\n    console.log(`Event listener registered for ${event} on channel ${this.id}`);\n  }\n\n  /**\n   * Registers a one-time event listener\n   */\n  once<T extends WebSocketEvent[\"type\"]>(\n    event: T,\n    listener: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!event) {\n      throw new Error(\"Event type is required\");\n    }\n\n    const wrappedListener = (data: WebSocketEvent) => {\n      if (\"channel\" in data && data.channel?.id === this.id) {\n        listener(data as Extract<WebSocketEvent, { type: T }>);\n      }\n    };\n    this.eventEmitter.once(event, wrappedListener);\n    console.log(\n      `One-time event listener registered for ${event} on channel ${this.id}`,\n    );\n  }\n\n  /**\n   * Removes event listener(s) for a specific WebSocket event type.\n   * If a specific listener is provided, only that listener is removed.\n   * Otherwise, all listeners for the given event type are removed.\n   *\n   * @param {T} event - The type of WebSocket event to remove listener(s) for\n   * @param {Function} [listener] - Optional specific listener to remove\n   * @throws {Error} If no event type is provided\n   */\n  off<T extends WebSocketEvent[\"type\"]>(\n    event: T,\n    listener?: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!event) {\n      throw new Error(\"Event type is required\");\n    }\n\n    if (listener) {\n      this.eventEmitter.off(event, listener);\n      console.log(\n        `Specific listener removed for ${event} on channel ${this.id}`,\n      );\n    } else {\n      this.eventEmitter.removeAllListeners(event);\n      console.log(`All listeners removed for ${event} on channel ${this.id}`);\n    }\n  }\n\n  /**\n   * Emits an event if it matches the current channel\n   */\n  emitEvent(event: WebSocketEvent): void {\n    if (!event) {\n      console.warn(\"Received invalid event\");\n      return;\n    }\n\n    if (\"channel\" in event && event.channel?.id === this.id) {\n      this.eventEmitter.emit(event.type, event);\n      console.log(`Event ${event.type} emitted for channel ${this.id}`);\n    }\n  }\n\n  /**\n   * Removes all event listeners associated with the current instance.\n   * This ensures that there are no lingering event handlers for the channel.\n   *\n   * @return {void} This method does not return a value.\n   */\n  removeAllListeners(): void {\n    console.log(`Removendo todos os listeners para o canal ${this.id}`);\n    this.eventEmitter.removeAllListeners();\n  }\n\n  /**\n   * Answers the channel\n   */\n  async answer(): Promise<void> {\n    try {\n      await this.baseClient.post<void>(`/channels/${this.id}/answer`);\n      console.log(`Channel ${this.id} answered`);\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error answering channel ${this.id}:`, message);\n      throw new Error(`Failed to answer channel: ${message}`);\n    }\n  }\n\n  /**\n   * Originates a new channel\n   *\n   * @param data - Channel origination configuration\n   * @returns Promise resolving to the created channel\n   * @throws Error if channel already exists or origination fails\n   */\n  async originate(data: OriginateRequest): Promise<Channel> {\n    if (this.channelData) {\n      throw new Error(\"Channel has already been created\");\n    }\n\n    try {\n      this.channelData = await this.baseClient.post<Channel, OriginateRequest>(\n        \"/channels\",\n        data,\n      );\n      console.log(\n        `Channel originated successfully with ID: ${this.channelData.id}`,\n      );\n      return this.channelData;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error originating channel:`, message);\n      throw new Error(`Failed to originate channel: ${message}`);\n    }\n  }\n\n  /**\n   * Plays media on the channel\n   */\n  async play(\n    options: { media: string; lang?: string },\n    playbackId?: string,\n  ): Promise<PlaybackInstance> {\n    if (!options.media) {\n      throw new Error(\"Media URL is required\");\n    }\n\n    try {\n      if (!this.channelData) {\n        console.log(\"Initializing channel details...\");\n        this.channelData = await this.getDetails();\n      }\n\n      const playback = this.client.Playback(playbackId || uuidv4());\n      await this.baseClient.post<void>(\n        `/channels/${this.id}/play/${playback.id}`,\n        options,\n      );\n\n      console.log(`Media playback started on channel ${this.id}`);\n      return playback;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error playing media on channel ${this.id}:`, message);\n      throw new Error(`Failed to play media: ${message}`);\n    }\n  }\n\n  /**\n   * Gets the current channel details\n   */\n  async getDetails(): Promise<Channel> {\n    try {\n      if (this.channelData) {\n        return this.channelData;\n      }\n\n      if (!this.id) {\n        throw new Error(\"No channel ID associated with this instance\");\n      }\n\n      const details = await this.baseClient.get<Channel>(\n        `/channels/${this.id}`,\n      );\n      this.channelData = details;\n      console.log(`Retrieved channel details for ${this.id}`);\n      return details;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(\n        `Error retrieving channel details for ${this.id}:`,\n        message,\n      );\n      throw new Error(`Failed to get channel details: ${message}`);\n    }\n  }\n\n  /**\n   * Checks if the channel has any listeners for a specific event\n   */\n  hasListeners(event: string): boolean {\n    return this.eventEmitter.listenerCount(event) > 0;\n  }\n\n  /**\n   * Gets the count of listeners for a specific event\n   */\n  getListenerCount(event: string): number {\n    return this.eventEmitter.listenerCount(event);\n  }\n\n  /**\n   * Fetches a specific channel variable.\n   *\n   * @param {string} variable - The name of the variable to retrieve. This parameter is required.\n   * @return {Promise<ChannelVar>} A promise that resolves with the value of the requested channel variable.\n   * @throws {Error} If the 'variable' parameter is not provided.\n   */\n  async getVariable(variable: string): Promise<ChannelVar> {\n    if (!variable) {\n      throw new Error(\"The 'variable' parameter is required.\");\n    }\n    return this.baseClient.get<ChannelVar>(\n      `/channels/${this.id}/variable?variable=${encodeURIComponent(variable)}`,\n    );\n  }\n\n  /**\n   * Terminates the active call associated with the current channel.\n   * This method ensures that channel details are initialized before attempting to hang up.\n   * If the channel ID is invalid or cannot be determined, an error is thrown.\n   *\n   * @return {Promise<void>} A promise that resolves when the call is successfully terminated.\n   */\n  async hangup(): Promise<void> {\n    if (!this.channelData) {\n      console.log(\"Canal n\u00E3o inicializado, buscando detalhes...\");\n      this.channelData = await this.getDetails();\n    }\n\n    if (!this.channelData?.id) {\n      throw new Error(\"N\u00E3o foi poss\u00EDvel inicializar o canal. ID inv\u00E1lido.\");\n    }\n\n    await this.baseClient.delete(`/channels/${this.channelData.id}`);\n  }\n\n  /**\n   * Plays media on the specified channel using the provided media URL and optional playback options.\n   *\n   * @param {string} media - The URL or identifier of the media to be played.\n   * @param {PlaybackOptions} [options] - Optional playback settings such as volume, playback speed, etc.\n   * @return {Promise<ChannelPlayback>} A promise that resolves with the playback details for the channel.\n   * @throws {Error} Throws an error if the channel has not been created.\n   */\n  async playMedia(\n    media: string,\n    options?: PlaybackOptions,\n  ): Promise<ChannelPlayback> {\n    if (!this.channelData) {\n      throw new Error(\"O canal ainda n\u00E3o foi criado.\");\n    }\n\n    const queryParams = options\n      ? `?${new URLSearchParams(options as Record<string, string>).toString()}`\n      : \"\";\n\n    return this.baseClient.post<ChannelPlayback>(\n      `/channels/${this.channelData.id}/play${queryParams}`,\n      { media },\n    );\n  }\n\n  /**\n   * Stops the playback for the given playback ID.\n   *\n   * @param {string} playbackId - The unique identifier for the playback to be stopped.\n   * @return {Promise<void>} A promise that resolves when the playback is successfully stopped.\n   * @throws {Error} Throws an error if the instance is not associated with a channel.\n   */\n  async stopPlayback(playbackId: string): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.delete<void>(\n      `/channels/${this.channelData.id}/play/${playbackId}`,\n    );\n  }\n\n  /**\n   * Pauses the playback of the specified media on a channel.\n   *\n   * @param {string} playbackId - The unique identifier of the playback to be paused.\n   * @return {Promise<void>} A promise that resolves when the playback has been successfully paused.\n   * @throws {Error} Throws an error if the channel is not associated with the current instance.\n   */\n  async pausePlayback(playbackId: string): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.post<void>(\n      `/channels/${this.channelData.id}/play/${playbackId}/pause`,\n    );\n  }\n\n  /**\n   * Resumes playback of the specified playback session on the associated channel.\n   *\n   * @param {string} playbackId - The unique identifier of the playback session to be resumed.\n   * @return {Promise<void>} A promise that resolves when the playback has been successfully resumed.\n   * @throws {Error} Throws an error if the channel is not associated with this instance.\n   */\n  async resumePlayback(playbackId: string): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.delete<void>(\n      `/channels/${this.channelData.id}/play/${playbackId}/pause`,\n    );\n  }\n\n  /**\n   * Rewinds the playback of a media by a specified amount of milliseconds.\n   *\n   * @param {string} playbackId - The unique identifier for the playback session to be rewound.\n   * @param {number} skipMs - The number of milliseconds to rewind the playback.\n   * @return {Promise<void>} A promise that resolves when the rewind operation is complete.\n   */\n  async rewindPlayback(playbackId: string, skipMs: number): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.post<void>(\n      `/channels/${this.channelData.id}/play/${playbackId}/rewind`,\n      { skipMs },\n    );\n  }\n\n  /**\n   * Fast forwards the playback by a specific duration in milliseconds.\n   *\n   * @param {string} playbackId - The unique identifier of the playback to be fast-forwarded.\n   * @param {number} skipMs - The number of milliseconds to fast forward the playback.\n   * @return {Promise<void>} A Promise that resolves when the fast-forward operation is complete.\n   * @throws {Error} If no channel is associated with this instance.\n   */\n  async fastForwardPlayback(playbackId: string, skipMs: number): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.post<void>(\n      `/channels/${this.channelData.id}/play/${playbackId}/forward`,\n      { skipMs },\n    );\n  }\n\n  /**\n   * Mutes the specified channel for the given direction.\n   *\n   * @param {(\"both\" | \"in\" | \"out\")} [direction=\"both\"] - The direction to mute the channel. It can be \"both\" to mute incoming and outgoing, \"in\" to mute incoming, or \"out\" to mute outgoing.\n   * @return {Promise<void>} A promise that resolves when the channel is successfully muted.\n   * @throws {Error} If the channel is not associated with this instance.\n   */\n  async muteChannel(direction: \"both\" | \"in\" | \"out\" = \"both\"): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.post<void>(\n      `/channels/${this.channelData.id}/mute?direction=${direction}`,\n    );\n  }\n\n  /**\n   * Unmutes a previously muted channel in the specified direction.\n   *\n   * @param {\"both\" | \"in\" | \"out\"} direction - The direction in which to unmute the channel.\n   *        Defaults to \"both\", which unmutes both incoming and outgoing communication.\n   * @return {Promise<void>} A promise that resolves once the channel has been successfully unmuted.\n   * @throws {Error} If the channel is not associated with the current instance.\n   */\n  async unmuteChannel(\n    direction: \"both\" | \"in\" | \"out\" = \"both\",\n  ): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.delete<void>(\n      `/channels/${this.channelData.id}/mute?direction=${direction}`,\n    );\n  }\n\n  /**\n   * Places the associated channel on hold if the channel is valid and linked to this instance.\n   *\n   * @return {Promise<void>} A promise that resolves when the hold action is successfully executed.\n   * @throws {Error} Throws an error if the channel is not associated with this instance.\n   */\n  async holdChannel(): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.post<void>(`/channels/${this.channelData.id}/hold`);\n  }\n\n  /**\n   * Removes the hold status from a specific channel associated with this instance.\n   * The method sends a delete request to the server to release the hold on the channel.\n   * If no channel is associated with this instance, an error will be thrown.\n   *\n   * @return {Promise<void>} A promise that resolves when the channel hold has been successfully removed.\n   * @throws {Error} If no channel is associated with this instance.\n   */\n  async unholdChannel(): Promise<void> {\n    if (!this.channelData?.id) {\n      throw new Error(\"Canal n\u00E3o associado a esta inst\u00E2ncia.\");\n    }\n\n    await this.baseClient.delete<void>(`/channels/${this.channelData.id}/hold`);\n  }\n}\n\n/**\n * The `Channels` class provides a comprehensive interface for managing\n * and interacting with communication channels.\n */\nexport class Channels {\n  private readonly channelInstances = new Map<string, ChannelInstance>();\n\n  constructor(\n    private readonly baseClient: BaseClient,\n    private readonly client: AriClient,\n  ) {}\n\n  /**\n   * Creates or retrieves a ChannelInstance.\n   *\n   * @param {Object} [params] - Optional parameters for getting/creating a channel instance\n   * @param {string} [params.id] - Optional ID of an existing channel\n   * @returns {ChannelInstance} The requested or new channel instance\n   * @throws {Error} If channel creation/retrieval fails\n   *\n   * @example\n   * // Create new channel without ID\n   * const channel1 = client.channels.Channel();\n   *\n   * // Create/retrieve channel with specific ID\n   * const channel2 = client.channels.Channel({ id: 'some-id' });\n   */\n  Channel(params?: { id?: string }): ChannelInstance {\n    try {\n      const id = params?.id;\n\n      if (!id) {\n        const instance = new ChannelInstance(this.client, this.baseClient);\n        this.channelInstances.set(instance.id, instance);\n        console.log(`New channel instance created with ID: ${instance.id}`);\n        return instance;\n      }\n\n      if (!this.channelInstances.has(id)) {\n        const instance = new ChannelInstance(this.client, this.baseClient, id);\n        this.channelInstances.set(id, instance);\n        console.log(`New channel instance created with provided ID: ${id}`);\n        return instance;\n      }\n\n      console.log(`Returning existing channel instance: ${id}`);\n      return this.channelInstances.get(id)!;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error creating/retrieving channel instance:`, message);\n      throw new Error(`Failed to manage channel instance: ${message}`);\n    }\n  }\n\n  /**\n   * Retrieves the details of a specific channel.\n   *\n   * @param {string} id - The unique identifier of the channel to retrieve.\n   * @returns {Promise<Channel>} A promise that resolves to the Channel object containing the channel details.\n   * @throws {Error} If no channel ID is associated with this instance or if there's an error retrieving the channel details.\n   */\n  async get(id: string): Promise<Channel> {\n    try {\n      if (id) {\n        throw new Error(\"No channel ID associated with this instance\");\n      }\n  \n      const details = await this.baseClient.get<Channel>(`/channels/${id}`);\n      console.log(`Retrieved channel details for ${id}`);\n      return details;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error retrieving channel details for ${id}:`, message);\n      throw new Error(`Failed to get channel details: ${message}`);\n    }\n  }\n\n  /**\n   * Removes a channel instance from the collection.\n   */\n  removeChannelInstance(channelId: string): void {\n    if (!channelId) {\n      throw new Error(\"Channel ID is required\");\n    }\n\n    if (this.channelInstances.has(channelId)) {\n      const instance = this.channelInstances.get(channelId);\n      instance?.removeAllListeners();\n      this.channelInstances.delete(channelId);\n      console.log(`Channel instance removed: ${channelId}`);\n    } else {\n      console.warn(`Attempt to remove non-existent instance: ${channelId}`);\n    }\n  }\n\n  /**\n   * Propagates a WebSocket event to a specific channel.\n   */\n  propagateEventToChannel(event: WebSocketEvent): void {\n    if (!event) {\n      console.warn(\"Invalid WebSocket event received\");\n      return;\n    }\n\n    if (\"channel\" in event && event.channel?.id) {\n      const instance = this.channelInstances.get(event.channel.id);\n      if (instance) {\n        instance.emitEvent(event);\n        console.log(\n          `Event propagated to channel ${event.channel.id}: ${event.type}`,\n        );\n      } else {\n        console.warn(`No instance found for channel ${event.channel.id}`);\n      }\n    }\n  }\n\n  /**\n   * Initiates a new channel.\n   */\n  async originate(data: OriginateRequest): Promise<Channel> {\n    if (!data.endpoint) {\n      throw new Error(\"Endpoint is required for channel origination\");\n    }\n\n    try {\n      const channel = await this.baseClient.post<Channel>(\"/channels\", data);\n      console.log(`Channel originated successfully with ID: ${channel.id}`);\n      return channel;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error originating channel:`, message);\n      throw new Error(`Failed to originate channel: ${message}`);\n    }\n  }\n\n  /**\n   * Lists all active channels.\n   */\n  async list(): Promise<Channel[]> {\n    try {\n      const channels = await this.baseClient.get<unknown>(\"/channels\");\n      if (!Array.isArray(channels)) {\n        throw new Error(\"API response for /channels is not an array\");\n      }\n      console.log(`Retrieved ${channels.length} active channels`);\n      return channels as Channel[];\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error listing channels:`, message);\n      throw new Error(`Failed to list channels: ${message}`);\n    }\n  }\n\n  /**\n   * Gets the count of active channel instances.\n   */\n  getInstanceCount(): number {\n    return this.channelInstances.size;\n  }\n\n  /**\n   * Checks if a channel instance exists.\n   */\n  hasInstance(channelId: string): boolean {\n    return this.channelInstances.has(channelId);\n  }\n\n  /**\n   * Gets all active channel instances.\n   */\n  getAllInstances(): Map<string, ChannelInstance> {\n    return new Map(this.channelInstances);\n  }\n\n  /**\n   * Terminates an active call on the specified channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel to hang up.\n   * @param {Object} [options] - Optional parameters for the hangup request.\n   * @param {string} [options.reason_code] - A code indicating the reason for the hangup.\n   * @param {string} [options.reason] - A descriptive reason for the hangup.\n   * @return {Promise<void>} A promise that resolves when the call has been successfully terminated.\n   */\n  async hangup(\n    channelId: string,\n    options?: { reason_code?: string; reason?: string },\n  ): Promise<void> {\n    const queryParams = new URLSearchParams({\n      ...(options?.reason_code && { reason_code: options.reason_code }),\n      ...(options?.reason && { reason: options.reason }),\n    });\n\n    return this.baseClient.delete<void>(\n      `/channels/${channelId}?${queryParams.toString()}`,\n    );\n  }\n\n  /**\n   * Initiates snooping on a specified channel with the provided options.\n   *\n   * @param {string} channelId - The unique identifier of the channel to snoop on.\n   * @param {SnoopOptions} options - Configuration options for the snooping operation.\n   * @return {Promise<Channel>} A promise that resolves to the snooped channel data.\n   */\n  async snoopChannel(\n    channelId: string,\n    options: SnoopOptions,\n  ): Promise<Channel> {\n    const queryParams = toQueryParams(options);\n    return this.baseClient.post<Channel>(\n      `/channels/${channelId}/snoop?${queryParams}`,\n    );\n  }\n\n  /**\n   * Starts a silence mode for the specified channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel where silence mode should be started.\n   * @return {Promise<void>} A promise that resolves when the silence mode is successfully started.\n   */\n  async startSilence(channelId: string): Promise<void> {\n    return this.baseClient.post<void>(`/channels/${channelId}/silence`);\n  }\n\n  /**\n   * Stops the silence mode for a specific channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel for which silence mode should be stopped.\n   * @return {Promise<void>} A promise that resolves when the operation is complete.\n   */\n  async stopSilence(channelId: string): Promise<void> {\n    return this.baseClient.delete<void>(`/channels/${channelId}/silence`);\n  }\n\n  /**\n   * Retrieves the Real-Time Protocol (RTP) statistics for a specific channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel for which RTP statistics are fetched.\n   * @return {Promise<RTPStats>} A promise that resolves to the RTP statistics for the specified channel.\n   */\n  async getRTPStatistics(channelId: string): Promise<RTPStats> {\n    return this.baseClient.get<RTPStats>(\n      `/channels/${channelId}/rtp_statistics`,\n    );\n  }\n\n  /**\n   * Creates an external media channel with the given options.\n   *\n   * @param {ExternalMediaOptions} options - The configuration options for creating the external media channel.\n   * @return {Promise<Channel>} A promise that resolves with the created external media channel.\n   */\n  async createExternalMedia(options: ExternalMediaOptions): Promise<Channel> {\n    const queryParams = toQueryParams(options);\n    return this.baseClient.post<Channel>(\n      `/channels/externalMedia?${queryParams}`,\n    );\n  }\n\n  /**\n   * Initiates playback of a specific media item on a channel using the provided playback ID.\n   *\n   * @param {string} channelId - The unique identifier of the channel where playback will occur.\n   * @param {string} playbackId - The unique identifier for the specific playback session.\n   * @param {string} media - The media content to be played.\n   * @param {PlaybackOptions} [options] - Optional playback configuration parameters.\n   * @return {Promise<ChannelPlayback>} A promise that resolves with the playback details for the channel.\n   */\n  async playWithId(\n    channelId: string,\n    playbackId: string,\n    media: string,\n    options?: PlaybackOptions,\n  ): Promise<ChannelPlayback> {\n    const queryParams = options ? `?${toQueryParams(options)}` : \"\";\n    return this.baseClient.post<ChannelPlayback>(\n      `/channels/${channelId}/play/${playbackId}${queryParams}`,\n      { media },\n    );\n  }\n\n  /**\n   * Initiates a snoop operation on a specific channel using the provided channel ID and snoop ID.\n   *\n   * @param {string} channelId - The unique identifier of the channel to snoop on.\n   * @param {string} snoopId - The unique identifier for the snoop operation.\n   * @param {SnoopOptions} options - Additional options and parameters for the snoop operation.\n   * @return {Promise<Channel>} A promise that resolves to the channel details after the snoop operation is initiated.\n   */\n  async snoopChannelWithId(\n    channelId: string,\n    snoopId: string,\n    options: SnoopOptions,\n  ): Promise<Channel> {\n    const queryParams = toQueryParams(options);\n    return this.baseClient.post<Channel>(\n      `/channels/${channelId}/snoop/${snoopId}?${queryParams}`,\n    );\n  }\n\n  /**\n   * Starts Music on Hold for the specified channel with the provided Music on Hold class.\n   *\n   * @param {string} channelId - The unique identifier of the channel.\n   * @param {string} mohClass - The Music on Hold class to be applied.\n   * @return {Promise<void>} A promise that resolves when the operation is complete.\n   */\n  async startMohWithClass(channelId: string, mohClass: string): Promise<void> {\n    const queryParams = `mohClass=${encodeURIComponent(mohClass)}`;\n    await this.baseClient.post<void>(\n      `/channels/${channelId}/moh?${queryParams}`,\n    );\n  }\n\n  /**\n   * Retrieves the value of a specified variable for a given channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel.\n   * @param {string} variable - The name of the variable to retrieve.\n   * @return {Promise<ChannelVar>} A promise that resolves to the value of the channel variable.\n   * @throws {Error} Throws an error if the 'variable' parameter is not provided.\n   */\n  async getChannelVariable(\n    channelId: string,\n    variable: string,\n  ): Promise<ChannelVar> {\n    if (!variable) {\n      throw new Error(\"The 'variable' parameter is required.\");\n    }\n    return this.baseClient.get<ChannelVar>(\n      `/channels/${channelId}/variable?variable=${encodeURIComponent(variable)}`,\n    );\n  }\n\n  /**\n   * Sets a variable for a specific channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel.\n   * @param {string} variable - The name of the variable to be set. This parameter is required.\n   * @param {string} [value] - The value of the variable to be set. This parameter is optional.\n   * @return {Promise<void>} A promise that resolves when the variable is successfully set.\n   * @throws {Error} Throws an error if the `variable` parameter is not provided.\n   */\n  async setChannelVariable(\n    channelId: string,\n    variable: string,\n    value?: string,\n  ): Promise<void> {\n    if (!variable) {\n      throw new Error(\"The 'variable' parameter is required.\");\n    }\n    const queryParams = new URLSearchParams({\n      variable,\n      ...(value && { value }),\n    });\n    await this.baseClient.post<void>(\n      `/channels/${channelId}/variable?${queryParams}`,\n    );\n  }\n\n  /**\n   * Moves a specified channel to the given application with optional arguments.\n   *\n   * @param {string} channelId - The unique identifier of the channel to be moved.\n   * @param {string} app - The target application to which the channel will be moved.\n   * @param {string} [appArgs] - Optional arguments to be passed to the target application.\n   * @return {Promise<void>} A promise that resolves when the operation is completed.\n   */\n  async moveToApplication(\n    channelId: string,\n    app: string,\n    appArgs?: string,\n  ): Promise<void> {\n    await this.baseClient.post<void>(`/channels/${channelId}/move`, {\n      app,\n      appArgs,\n    });\n  }\n\n  /**\n   * Continues the execution of a dialplan for a specific channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel.\n   * @param {string} [context] - The dialplan context to continue execution in, if specified.\n   * @param {string} [extension] - The dialplan extension to proceed with, if provided.\n   * @param {number} [priority] - The priority within the dialplan extension to resume at, if specified.\n   * @param {string} [label] - The label to start from within the dialplan, if given.\n   * @return {Promise<void>} Resolves when the dialplan is successfully continued.\n   */\n  async continueDialplan(\n    channelId: string,\n    context?: string,\n    extension?: string,\n    priority?: number,\n    label?: string,\n  ): Promise<void> {\n    await this.baseClient.post<void>(`/channels/${channelId}/continue`, {\n      context,\n      extension,\n      priority,\n      label,\n    });\n  }\n\n  /**\n   * Stops the music on hold for the specified channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel where music on hold should be stopped.\n   * @return {Promise<void>} Resolves when the music on hold is successfully stopped.\n   */\n  async stopMusicOnHold(channelId: string): Promise<void> {\n    await this.baseClient.delete<void>(`/channels/${channelId}/moh`);\n  }\n\n  /**\n   * Initiates the music on hold for the specified channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel where the music on hold will be started.\n   * @return {Promise<void>} A promise that resolves when the operation has been successfully invoked.\n   */\n  async startMusicOnHold(channelId: string): Promise<void> {\n    await this.baseClient.post<void>(`/channels/${channelId}/moh`);\n  }\n\n  /**\n   * Starts recording for a specific channel based on the provided options.\n   *\n   * @param {string} channelId - The unique identifier of the channel to start recording.\n   * @param {RecordingOptions} options - The recording options to configure the recording process.\n   * @return {Promise<Channel>} A promise that resolves to the channel object with updated recording state.\n   */\n  async record(channelId: string, options: RecordingOptions): Promise<Channel> {\n    const queryParams = toQueryParams(options);\n    return this.baseClient.post<Channel>(\n      `/channels/${channelId}/record?${queryParams}`,\n    );\n  }\n\n  /**\n   * Initiates a call on the specified channel with optional parameters for caller identification and timeout duration.\n   *\n   * @param {string} channelId - The ID of the channel where the call will be initiated.\n   * @param {string} [caller] - Optional parameter specifying the name or identifier of the caller.\n   * @param {number} [timeout] - Optional parameter defining the timeout duration for the call in seconds.\n   * @return {Promise<void>} A promise that resolves when the call has been successfully initiated.\n   */\n  async dial(\n    channelId: string,\n    caller?: string,\n    timeout?: number,\n  ): Promise<void> {\n    const queryParams = new URLSearchParams({\n      ...(caller && { caller }),\n      ...(timeout && { timeout: timeout.toString() }),\n    });\n    await this.baseClient.post<void>(\n      `/channels/${channelId}/dial?${queryParams}`,\n    );\n  }\n\n  /**\n   * Redirects a channel to the specified endpoint.\n   *\n   * This method sends a POST request to update the redirect endpoint for the given channel.\n   *\n   * @param {string} channelId - The unique identifier of the channel to be redirected.\n   * @param {string} endpoint - The new endpoint to redirect the channel to.\n   * @return {Promise<void>} A promise that resolves when the operation is complete.\n   */\n  async redirectChannel(channelId: string, endpoint: string): Promise<void> {\n    await this.baseClient.post<void>(\n      `/channels/${channelId}/redirect?endpoint=${encodeURIComponent(endpoint)}`,\n    );\n  }\n\n  /**\n   * Answers a specified channel by sending a POST request to the corresponding endpoint.\n   *\n   * @param {string} channelId - The unique identifier of the channel to be answered.\n   * @return {Promise<void>} A promise that resolves when the channel has been successfully answered.\n   */\n  async answerChannel(channelId: string): Promise<void> {\n    await this.baseClient.post<void>(`/channels/${channelId}/answer`);\n  }\n\n  /**\n   * Rings the specified channel by sending a POST request to the appropriate endpoint.\n   *\n   * @param {string} channelId - The unique identifier of the channel to be rung.\n   * @return {Promise<void>} A promise that resolves when the operation completes successfully.\n   */\n  async ringChannel(channelId: string): Promise<void> {\n    await this.baseClient.post<void>(`/channels/${channelId}/ring`);\n  }\n\n  /**\n   * Stops the ring channel for the specified channel ID.\n   *\n   * This method sends a DELETE request to the server to stop the ring action\n   * associated with the provided channel ID.\n   *\n   * @param {string} channelId - The unique identifier of the channel for which the ring action should be stopped.\n   * @return {Promise<void>} A promise that resolves when the ring channel is successfully stopped.\n   */\n  async stopRingChannel(channelId: string): Promise<void> {\n    await this.baseClient.delete<void>(`/channels/${channelId}/ring`);\n  }\n\n  /**\n   * Sends DTMF (Dual-Tone Multi-Frequency) signals to a specified channel.\n   *\n   * @param {string} channelId - The ID of the channel to which the DTMF signals should be sent.\n   * @param {string} dtmf - The DTMF tones to be sent, represented as a string. Each character corresponds to a specific tone.\n   * @param {Object} [options] - Optional configuration for the DTMF signal timing.\n   * @param {number} [options.before] - Time in milliseconds to wait before sending the first DTMF tone.\n   * @param {number} [options.between] - Time in milliseconds to wait between sending successive DTMF tones.\n   * @param {number} [options.duration] - Duration in milliseconds for each DTMF tone.\n   * @param {number} [options.after] - Time in milliseconds to wait after sending the last DTMF tone.\n   * @return {Promise<void>} A promise that resolves when the DTMF signals are successfully sent.\n   */\n  async sendDTMF(\n    channelId: string,\n    dtmf: string,\n    options?: {\n      before?: number;\n      between?: number;\n      duration?: number;\n      after?: number;\n    },\n  ): Promise<void> {\n    const queryParams = toQueryParams({ dtmf, ...options });\n    await this.baseClient.post<void>(\n      `/channels/${channelId}/dtmf?${queryParams}`,\n    );\n  }\n\n  /**\n   * Mutes a specified channel in the given direction.\n   *\n   * @param {string} channelId - The unique identifier of the channel to be muted.\n   * @param {\"both\" | \"in\" | \"out\"} [direction=\"both\"] - The direction for muting, can be \"both\", \"in\", or \"out\". Default is \"both\".\n   * @return {Promise<void>} A promise that resolves when the channel is successfully muted.\n   */\n  async muteChannel(\n    channelId: string,\n    direction: \"both\" | \"in\" | \"out\" = \"both\",\n  ): Promise<void> {\n    await this.baseClient.post<void>(\n      `/channels/${channelId}/mute?direction=${direction}`,\n    );\n  }\n\n  /**\n   * Unmutes a previously muted channel, allowing communication in the specified direction(s).\n   *\n   * @param {string} channelId - The unique identifier of the channel to be unmuted.\n   * @param {\"both\" | \"in\" | \"out\"} [direction=\"both\"] - The direction of communication to unmute. Valid options are \"both\", \"in\" (incoming messages), or \"out\" (outgoing messages). Defaults to \"both\".\n   * @return {Promise<void>} A promise that resolves when the channel is successfully unmuted.\n   */\n  async unmuteChannel(\n    channelId: string,\n    direction: \"both\" | \"in\" | \"out\" = \"both\",\n  ): Promise<void> {\n    await this.baseClient.delete<void>(\n      `/channels/${channelId}/mute?direction=${direction}`,\n    );\n  }\n\n  /**\n   * Places a specific channel on hold by sending a POST request to the server.\n   *\n   * @param {string} channelId - The unique identifier of the channel to be placed on hold.\n   * @return {Promise<void>} A promise that resolves when the channel hold operation is completed.\n   */\n  async holdChannel(channelId: string): Promise<void> {\n    await this.baseClient.post<void>(`/channels/${channelId}/hold`);\n  }\n\n  /**\n   * Removes the hold status from a specific channel by its ID.\n   *\n   * @param {string} channelId - The unique identifier of the channel to unhold.\n   * @return {Promise<void>} A promise that resolves when the channel hold is successfully removed.\n   */\n  async unholdChannel(channelId: string): Promise<void> {\n    await this.baseClient.delete<void>(`/channels/${channelId}/hold`);\n  }\n\n  /**\n   * Creates a new communication channel with the specified configuration.\n   *\n   * @param {OriginateRequest} data - The configuration data required to create the channel, including relevant details such as endpoint and channel variables.\n   * @return {Promise<Channel>} A promise that resolves with the details of the created channel.\n   */\n  async createChannel(data: OriginateRequest): Promise<Channel> {\n    return this.baseClient.post<Channel>(\"/channels/create\", data);\n  }\n\n  /**\n   * Initiates a new channel with the specified channel ID and originates a call using the provided data.\n   *\n   * @param {string} channelId - The unique identifier of the channel to be created.\n   * @param {OriginateRequest} data - The data required to originate the call, including details such as endpoint and caller information.\n   * @return {Promise<Channel>} A promise that resolves to the created Channel object.\n   */\n  async originateWithId(\n    channelId: string,\n    data: OriginateRequest,\n  ): Promise<Channel> {\n    return this.baseClient.post<Channel>(`/channels/${channelId}`, data);\n  }\n}\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "import { randomFillSync } from 'crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n", "import { randomUUID } from 'crypto';\nexport default { randomUUID };\n", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || rng)();\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n", "import type { Channel, WebSocketEvent } from \"./interfaces\";\n\nexport function toQueryParams<T>(options: T): string {\n  return new URLSearchParams(\n    Object.entries(options as Record<string, string>)\n      .filter(([, value]) => value !== undefined)\n      .map(([key, value]) => [key, value as string]),\n  ).toString();\n}\n\nexport function isPlaybackEvent(\n  event: WebSocketEvent,\n  playbackId?: string,\n): event is Extract<WebSocketEvent, { playbackId: string }> {\n  const hasPlayback = \"playback\" in event && event.playback?.id !== undefined;\n  return hasPlayback && (!playbackId || event.playback?.id === playbackId);\n}\n\n/**\n * Verifica se um evento pertence a um canal e opcionalmente valida o ID do canal.\n * @param event O evento WebSocket a ser validado.\n * @param channelId Opcional. O ID do canal a ser validado.\n * @returns Verdadeiro se o evento \u00E9 relacionado a um canal (e ao ID, se fornecido).\n */\nexport function isChannelEvent(\n  event: WebSocketEvent,\n  channelId?: string,\n): event is Extract<WebSocketEvent, { channel: Channel }> {\n  // Verifica se o evento tem a propriedade `channel`\n  const hasChannel = \"channel\" in event && event.channel?.id !== undefined;\n\n  return hasChannel && (!channelId || event.channel?.id === channelId);\n}\n\nexport const channelEvents = [\n  \"ChannelCreated\",\n  \"ChannelDestroyed\",\n  \"ChannelEnteredBridge\",\n  \"ChannelLeftBridge\",\n  \"ChannelStateChange\",\n  \"ChannelDtmfReceived\",\n  \"ChannelDialplan\",\n  \"ChannelCallerId\",\n  \"ChannelUserevent\",\n  \"ChannelHangupRequest\",\n  \"ChannelVarset\",\n  \"ChannelTalkingStarted\",\n  \"ChannelTalkingFinished\",\n  \"ChannelHold\",\n  \"ChannelUnhold\",\n];\n", "import type { BaseClient } from \"../baseClient.js\";\nimport type { Endpoint, EndpointDetails } from \"../interfaces/endpoints.types\";\n\nexport class Endpoints {\n  constructor(private client: BaseClient) {}\n\n  /**\n   * Lists all available endpoints.\n   *\n   * @returns A promise that resolves to an array of Endpoint objects representing all available endpoints.\n   * @throws {Error} If the API response is not an array.\n   */\n  async list(): Promise<Endpoint[]> {\n    const endpoints = await this.client.get<unknown>(\"/endpoints\");\n\n    if (!Array.isArray(endpoints)) {\n      throw new Error(\"Resposta da API /endpoints n\u00E3o \u00E9 um array.\");\n    }\n\n    return endpoints as Endpoint[];\n  }\n\n  /**\n   * Retrieves details of a specific endpoint.\n   *\n   * @param technology - The technology of the endpoint (e.g., \"PJSIP\").\n   * @param resource - The specific resource name of the endpoint (e.g., \"9001\").\n   * @returns A promise that resolves to an EndpointDetails object containing the details of the specified endpoint.\n   */\n  async getDetails(\n    technology: string,\n    resource: string,\n  ): Promise<EndpointDetails> {\n    return this.client.get<EndpointDetails>(\n      `/endpoints/${technology}/${resource}`,\n    );\n  }\n\n  /**\n   * Sends a message to a specific endpoint.\n   *\n   * @param technology - The technology of the endpoint (e.g., \"PJSIP\").\n   * @param resource - The specific resource name of the endpoint (e.g., \"9001\").\n   * @param message - The message payload to send to the endpoint.\n   * @returns A promise that resolves when the message has been successfully sent.\n   */\n  async sendMessage(\n    technology: string,\n    resource: string,\n    message: Record<string, unknown>,\n  ): Promise<void> {\n    await this.client.post<void>(\n      `/endpoints/${technology}/${resource}/sendMessage`,\n      message,\n    );\n  }\n}\n", "import { EventEmitter } from \"events\";\nimport { isAxiosError } from \"axios\";\nimport type { AriClient } from \"../ariClient\";\nimport type { BaseClient } from \"../baseClient.js\";\nimport type { Playback, WebSocketEvent } from \"../interfaces\";\n\n/**\n * Utility function to extract error message\n * @param error - The error object to process\n * @returns A formatted error message\n */\nconst getErrorMessage = (error: unknown): string => {\n  if (isAxiosError(error)) {\n    return (\n      error.response?.data?.message ||\n      error.message ||\n      \"An axios error occurred\"\n    );\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return \"An unknown error occurred\";\n};\n\n/**\n * Represents a playback instance that provides methods for controlling media playback,\n * managing event listeners, and handling playback state.\n */\nexport class PlaybackInstance {\n  private readonly eventEmitter = new EventEmitter();\n  private playbackData: Playback | null = null;\n  public readonly id: string;\n\n  /**\n   * Creates a new PlaybackInstance.\n   *\n   * @param {AriClient} client - ARI client for communication\n   * @param {BaseClient} baseClient - Base client for HTTP requests\n   * @param {string} [playbackId] - Optional playback ID, generates timestamp-based ID if not provided\n   */\n  constructor(\n    private readonly client: AriClient,\n    private readonly baseClient: BaseClient,\n    private readonly playbackId: string = `playback-${Date.now()}`,\n  ) {\n    this.id = playbackId;\n    console.log(`PlaybackInstance initialized with ID: ${this.id}`);\n  }\n\n  /**\n   * Registers an event listener for a specific WebSocket event type.\n   *\n   * @param {T} event - Event type to listen for\n   * @param {Function} listener - Callback function for the event\n   */\n  on<T extends WebSocketEvent[\"type\"]>(\n    event: T,\n    listener: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!event) {\n      throw new Error(\"Event type is required\");\n    }\n\n    const wrappedListener = (data: WebSocketEvent) => {\n      if (\"playback\" in data && data.playback?.id === this.id) {\n        listener(data as Extract<WebSocketEvent, { type: T }>);\n      }\n    };\n    this.eventEmitter.on(event, wrappedListener);\n    console.log(\n      `Event listener registered for ${event} on playback ${this.id}`,\n    );\n  }\n\n  /**\n   * Registers a one-time event listener for a specific WebSocket event type.\n   *\n   * @param {T} event - Event type to listen for\n   * @param {Function} listener - Callback function for the event\n   */\n  once<T extends WebSocketEvent[\"type\"]>(\n    event: T,\n    listener: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!event) {\n      throw new Error(\"Event type is required\");\n    }\n\n    const wrappedListener = (data: WebSocketEvent) => {\n      if (\"playback\" in data && data.playback?.id === this.id) {\n        listener(data as Extract<WebSocketEvent, { type: T }>);\n      }\n    };\n    this.eventEmitter.once(event, wrappedListener);\n    console.log(\n      `One-time event listener registered for ${event} on playback ${this.id}`,\n    );\n  }\n\n  /**\n   * Removes event listener(s) for a specific WebSocket event type.\n   *\n   * @param {T} event - Event type to remove listener(s) for\n   * @param {Function} [listener] - Optional specific listener to remove\n   */\n  off<T extends WebSocketEvent[\"type\"]>(\n    event: T,\n    listener?: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!event) {\n      throw new Error(\"Event type is required\");\n    }\n\n    if (listener) {\n      this.eventEmitter.off(event, listener);\n      console.log(\n        `Specific listener removed for ${event} on playback ${this.id}`,\n      );\n    } else {\n      this.eventEmitter.removeAllListeners(event);\n      console.log(`All listeners removed for ${event} on playback ${this.id}`);\n    }\n  }\n\n  /**\n   * Emits a WebSocket event if it matches the current playback instance.\n   *\n   * @param {WebSocketEvent} event - Event to emit\n   */\n  emitEvent(event: WebSocketEvent): void {\n    if (!event) {\n      console.warn(\"Received invalid event\");\n      return;\n    }\n\n    if (\"playback\" in event && event.playback?.id === this.id) {\n      this.eventEmitter.emit(event.type, event);\n      console.log(`Event ${event.type} emitted for playback ${this.id}`);\n    }\n  }\n\n  /**\n   * Retrieves current playback data.\n   *\n   * @returns {Promise<Playback>} Current playback data\n   * @throws {Error} If playback is not properly initialized\n   */\n  async get(): Promise<Playback> {\n    if (!this.id) {\n      throw new Error(\"No playback associated with this instance\");\n    }\n\n    try {\n      this.playbackData = await this.baseClient.get<Playback>(\n        `/playbacks/${this.id}`,\n      );\n      console.log(`Retrieved playback data for ${this.id}`);\n      return this.playbackData;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error retrieving playback data for ${this.id}:`, message);\n      throw new Error(`Failed to get playback data: ${message}`);\n    }\n  }\n\n  /**\n   * Controls playback with specified operation.\n   *\n   * @param {\"pause\" | \"unpause\" | \"reverse\" | \"forward\"} operation - Control operation to perform\n   * @throws {Error} If playback is not properly initialized or operation fails\n   */\n  async control(\n    operation: \"pause\" | \"unpause\" | \"reverse\" | \"forward\",\n  ): Promise<void> {\n    if (!this.id) {\n      throw new Error(\"No playback associated with this instance\");\n    }\n\n    try {\n      await this.baseClient.post<void>(\n        `/playbacks/${this.id}/control?operation=${operation}`,\n      );\n      console.log(\n        `Operation ${operation} executed successfully on playback ${this.id}`,\n      );\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error controlling playback ${this.id}:`, message);\n      throw new Error(`Failed to control playback: ${message}`);\n    }\n  }\n\n  /**\n   * Stops the current playback.\n   *\n   * @throws {Error} If playback is not properly initialized or stop operation fails\n   */\n  async stop(): Promise<void> {\n    if (!this.id) {\n      throw new Error(\"No playback associated with this instance\");\n    }\n\n    try {\n      await this.baseClient.delete<void>(`/playbacks/${this.id}`);\n      console.log(`Playback ${this.id} stopped successfully`);\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error stopping playback ${this.id}:`, message);\n      throw new Error(`Failed to stop playback: ${message}`);\n    }\n  }\n\n  /**\n   * Removes all event listeners from this playback instance.\n   */\n  removeAllListeners(): void {\n    this.eventEmitter.removeAllListeners();\n    console.log(`All listeners removed from playback ${this.id}`);\n  }\n\n  /**\n   * Checks if the playback instance has any listeners for a specific event.\n   *\n   * @param {string} event - Event type to check\n   * @returns {boolean} True if there are listeners for the event\n   */\n  hasListeners(event: string): boolean {\n    return this.eventEmitter.listenerCount(event) > 0;\n  }\n\n  /**\n   * Gets the current playback data without making an API call.\n   *\n   * @returns {Playback | null} Current playback data or null if not available\n   */\n  getCurrentData(): Playback | null {\n    return this.playbackData;\n  }\n}\n\n/**\n * Manages playback instances and their related operations in the Asterisk REST Interface.\n * This class provides functionality to create, control, and manage playback instances,\n * as well as handle WebSocket events related to playbacks.\n */\nexport class Playbacks {\n  private playbackInstances = new Map<string, PlaybackInstance>();\n\n  constructor(\n    private baseClient: BaseClient,\n    private client: AriClient,\n  ) {}\n\n  /**\n   * Gets or creates a playback instance\n   * @param {Object} [params] - Optional parameters for getting/creating a playback instance\n   * @param {string} [params.id] - Optional ID of an existing playback\n   * @returns {PlaybackInstance} The requested or new playback instance\n   */\n  Playback(params?: { id?: string }): PlaybackInstance {\n    try {\n      const id = params?.id;\n\n      if (!id) {\n        const instance = new PlaybackInstance(this.client, this.baseClient);\n        this.playbackInstances.set(instance.id, instance);\n        console.log(`New playback instance created with ID: ${instance.id}`);\n        return instance;\n      }\n\n      if (!this.playbackInstances.has(id)) {\n        const instance = new PlaybackInstance(this.client, this.baseClient, id);\n        this.playbackInstances.set(id, instance);\n        console.log(`New playback instance created with provided ID: ${id}`);\n        return instance;\n      }\n\n      console.log(`Returning existing playback instance: ${id}`);\n      return this.playbackInstances.get(id)!;\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error creating/retrieving playback instance:`, message);\n      throw new Error(`Failed to manage playback instance: ${message}`);\n    }\n  }\n\n  /**\n   * Removes a playback instance and cleans up its resources\n   * @param {string} playbackId - ID of the playback instance to remove\n   * @throws {Error} If the playback instance doesn't exist\n   */\n  removePlaybackInstance(playbackId: string): void {\n    if (!playbackId) {\n      throw new Error(\"Playback ID is required\");\n    }\n\n    if (this.playbackInstances.has(playbackId)) {\n      const instance = this.playbackInstances.get(playbackId);\n      instance?.removeAllListeners();\n      this.playbackInstances.delete(playbackId);\n      console.log(`Playback instance removed: ${playbackId}`);\n    } else {\n      console.warn(`Attempt to remove non-existent instance: ${playbackId}`);\n    }\n  }\n\n  /**\n   * Propagates WebSocket events to the corresponding playback instance\n   * @param {WebSocketEvent} event - The WebSocket event to propagate\n   */\n  propagateEventToPlayback(event: WebSocketEvent): void {\n    if (!event) {\n      console.warn(\"Invalid WebSocket event received\");\n      return;\n    }\n\n    if (\"playback\" in event && event.playback?.id) {\n      const instance = this.playbackInstances.get(event.playback.id);\n      if (instance) {\n        instance.emitEvent(event);\n        console.log(\n          `Event propagated to playback ${event.playback.id}: ${event.type}`,\n        );\n      } else {\n        console.warn(`No instance found for playback ${event.playback.id}`);\n      }\n    }\n  }\n\n  /**\n   * Retrieves details of a specific playback\n   * @param {string} playbackId - ID of the playback to get details for\n   * @returns {Promise<Playback>} Promise resolving to playback details\n   * @throws {Error} If the playback ID is invalid or the request fails\n   */\n  async getDetails(playbackId: string): Promise<Playback> {\n    if (!playbackId) {\n      throw new Error(\"Playback ID is required\");\n    }\n\n    try {\n      return await this.baseClient.get<Playback>(`/playbacks/${playbackId}`);\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error getting playback details ${playbackId}:`, message);\n      throw new Error(`Failed to get playback details: ${message}`);\n    }\n  }\n\n  /**\n   * Controls a specific playback instance\n   * @param {string} playbackId - ID of the playback to control\n   * @param {\"pause\" | \"unpause\" | \"reverse\" | \"forward\"} operation - Operation to perform\n   * @throws {Error} If the playback ID is invalid or the operation fails\n   */\n  async control(\n    playbackId: string,\n    operation: \"pause\" | \"unpause\" | \"reverse\" | \"forward\",\n  ): Promise<void> {\n    if (!playbackId) {\n      throw new Error(\"Playback ID is required\");\n    }\n\n    try {\n      const playback = this.Playback({ id: playbackId });\n      await playback.control(operation);\n      console.log(`Operation ${operation} executed on playback ${playbackId}`);\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error controlling playback ${playbackId}:`, message);\n      throw new Error(`Failed to control playback: ${message}`);\n    }\n  }\n\n  /**\n   * Stops a specific playback instance\n   * @param {string} playbackId - ID of the playback to stop\n   * @throws {Error} If the playback ID is invalid or the stop operation fails\n   */\n  async stop(playbackId: string): Promise<void> {\n    if (!playbackId) {\n      throw new Error(\"Playback ID is required\");\n    }\n\n    try {\n      const playback = this.Playback({ id: playbackId });\n      await playback.stop();\n      console.log(`Playback ${playbackId} stopped`);\n    } catch (error: unknown) {\n      const message = getErrorMessage(error);\n      console.error(`Error stopping playback ${playbackId}:`, message);\n      throw new Error(`Failed to stop playback: ${message}`);\n    }\n  }\n\n  /**\n   * Gets the count of active playback instances\n   * @returns {number} Number of active playback instances\n   */\n  getInstanceCount(): number {\n    return this.playbackInstances.size;\n  }\n\n  /**\n   * Checks if a playback instance exists\n   * @param {string} playbackId - ID of the playback to check\n   * @returns {boolean} True if the playback instance exists\n   */\n  hasInstance(playbackId: string): boolean {\n    return this.playbackInstances.has(playbackId);\n  }\n}\n", "import type { BaseClient } from \"../baseClient.js\";\nimport type { Sound, SoundListRequest } from \"../interfaces/sounds.types.js\";\n\nexport class Sounds {\n  constructor(private client: BaseClient) {}\n\n  /**\n   * Lists all available sounds.\n   *\n   * @param params - Optional parameters to filter the list of sounds.\n   * @returns A promise that resolves to an array of Sound objects.\n   * @throws {Error} If the API response is not an array.\n   */\n  async list(params?: SoundListRequest): Promise<Sound[]> {\n    const query = params\n      ? `?${new URLSearchParams(params as Record<string, string>).toString()}`\n      : \"\";\n\n    const sounds = await this.client.get<unknown>(`/sounds${query}`);\n\n    if (!Array.isArray(sounds)) {\n      throw new Error(\"Resposta da API /sounds n\u00E3o \u00E9 um array.\");\n    }\n\n    return sounds as Sound[];\n  }\n\n  /**\n   * Retrieves details of a specific sound.\n   *\n   * @param soundId - The unique identifier of the sound.\n   * @returns A promise that resolves to a Sound object containing the details of the specified sound.\n   */\n  async getDetails(soundId: string): Promise<Sound> {\n    return this.client.get<Sound>(`/sounds/${soundId}`);\n  }\n}\n", "import { EventEmitter } from \"events\";\nimport { type IBackOffOptions, backOff } from \"exponential-backoff\";\nimport WebSocket from \"ws\";\nimport type { AriClient } from \"./ariClient\";\nimport type { BaseClient } from \"./baseClient.js\";\nimport type { WebSocketEvent, WebSocketEventType } from \"./interfaces\";\n\nconst DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;\nconst DEFAULT_STARTING_DELAY = 500;\nconst DEFAULT_MAX_DELAY = 10000;\n\n/**\n * WebSocketClient handles real-time communication with the Asterisk server.\n * Extends EventEmitter to provide event-based communication patterns.\n */\nexport class WebSocketClient extends EventEmitter {\n  private ws?: WebSocket;\n  private isReconnecting = false;\n  private readonly maxReconnectAttempts = DEFAULT_MAX_RECONNECT_ATTEMPTS;\n\n  private readonly backOffOptions: IBackOffOptions = {\n    numOfAttempts: DEFAULT_MAX_RECONNECT_ATTEMPTS,\n    startingDelay: DEFAULT_STARTING_DELAY,\n    maxDelay: DEFAULT_MAX_DELAY,\n    timeMultiple: 2,\n    jitter: \"full\",\n    delayFirstAttempt: false,\n    retry: (error: Error, attemptNumber: number) => {\n      console.warn(\n          `Connection attempt #${attemptNumber} failed:`,\n          error.message || 'Unknown error'\n      );\n      return attemptNumber < this.maxReconnectAttempts;\n    },\n  };\n\n  /**\n   * Creates a new WebSocket client instance.\n   *\n   * @param {BaseClient} baseClient - The base client containing connection details\n   * @param {string[]} apps - List of applications to connect to\n   * @param {WebSocketEventType[]} [subscribedEvents] - Optional list of events to subscribe to\n   * @param {AriClient} [ariClient] - Optional ARI client for handling channel and playback events\n   */\n  constructor(\n      private readonly baseClient: BaseClient,\n      private readonly apps: string[],\n      private readonly subscribedEvents?: WebSocketEventType[],\n      private readonly ariClient?: AriClient,\n  ) {\n    super();\n\n    if (!apps.length) {\n      throw new Error(\"At least one application name is required\");\n    }\n  }\n\n  /**\n   * Establishes a WebSocket connection.\n   *\n   * @returns {Promise<void>} Resolves when connection is established\n   * @throws {Error} If connection fails\n   */\n  public async connect(): Promise<void> {\n    const { baseUrl, username, password } = this.baseClient.getCredentials();\n\n    // Determine correct protocol\n    const protocol = baseUrl.startsWith(\"https\") ? \"wss\" : \"ws\";\n\n    // Normalize host\n    const normalizedHost = baseUrl\n        .replace(/^https?:\\/\\//, \"\")\n        .replace(/\\/ari$/, \"\");\n\n    // Prepare query parameters\n    const queryParams = new URLSearchParams();\n    queryParams.append(\"app\", this.apps.join(\",\"));\n\n    if (this.subscribedEvents?.length) {\n      this.subscribedEvents.forEach(event =>\n          queryParams.append(\"event\", event)\n      );\n    } else {\n      queryParams.append(\"subscribeAll\", \"true\");\n    }\n\n    // Build final WebSocket URL\n    const wsUrl = `${protocol}://${encodeURIComponent(username)}:${encodeURIComponent(password)}@${normalizedHost}/ari/events?${queryParams.toString()}`;\n\n    console.log(\"Connecting to WebSocket...\");\n    return this.initializeWebSocket(wsUrl);\n  }\n\n  /**\n   * Initializes WebSocket connection with reconnection logic.\n   *\n   * @param {string} wsUrl - The WebSocket URL to connect to\n   * @returns {Promise<void>} Resolves when connection is established\n   */\n  private async initializeWebSocket(wsUrl: string): Promise<void> {\n    return backOff(async () => {\n      return new Promise<void>((resolve, reject) => {\n        try {\n          this.ws = new WebSocket(wsUrl);\n\n          this.ws.on(\"open\", () => {\n            console.log(\"WebSocket connection established successfully\");\n            this.isReconnecting = false;\n            this.emit(\"connected\");\n            resolve();\n          });\n\n          this.ws.on(\"message\", (data) => this.handleMessage(data.toString()));\n\n          this.ws.on(\"close\", (code) => {\n            console.warn(\n                `WebSocket disconnected with code ${code}. Attempting to reconnect...`\n            );\n            if (!this.isReconnecting) {\n              this.reconnect(wsUrl);\n            }\n          });\n\n          this.ws.on(\"error\", (err: Error) => {\n            console.error(\"WebSocket error:\", err.message);\n            if (!this.isReconnecting) {\n              this.reconnect(wsUrl);\n            }\n            reject(err);\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }, this.backOffOptions);\n  }\n\n  /**\n   * Processes incoming WebSocket messages.\n   *\n   * @param {string} rawMessage - The raw message received from WebSocket\n   */\n  private handleMessage(rawMessage: string): void {\n    try {\n      const event: WebSocketEvent = JSON.parse(rawMessage);\n\n      // Filter unsubscribed events\n      if (\n          this.subscribedEvents?.length &&\n          !this.subscribedEvents.includes(event.type as WebSocketEventType)\n      ) {\n        return;\n      }\n\n      // Process channel-related events\n      if (\"channel\" in event && event.channel?.id && this.ariClient) {\n        const instanceChannel = this.ariClient.Channel(event.channel.id);\n        instanceChannel.emitEvent(event);\n        event.instanceChannel = instanceChannel;\n      }\n\n      // Process playback-related events\n      if (\"playback\" in event && event.playback?.id && this.ariClient) {\n        const instancePlayback = this.ariClient.Playback(event.playback.id);\n        instancePlayback.emitEvent(event);\n        event.instancePlayback = instancePlayback;\n      }\n\n      this.emit(event.type, event);\n      console.log(`Event processed: ${event.type}`);\n    } catch (error) {\n      console.error(\"Error processing WebSocket message:\", error instanceof Error ? error.message : 'Unknown error');\n      this.emit(\"error\", new Error(\"Failed to decode WebSocket message\"));\n    }\n  }\n\n  /**\n   * Attempts to reconnect to the WebSocket.\n   *\n   * @param {string} wsUrl - The WebSocket URL to reconnect to\n   */\n  private reconnect(wsUrl: string): void {\n    this.isReconnecting = true;\n    console.log(\"Initiating reconnection attempt...\");\n    this.removeAllListeners();\n\n    backOff(() => this.initializeWebSocket(wsUrl), this.backOffOptions)\n        .catch((error) => {\n          console.error(\n              \"Failed to reconnect after multiple attempts:\",\n              error instanceof Error ? error.message : 'Unknown error'\n          );\n          this.emit(\"reconnectFailed\", error);\n        });\n  }\n\n  /**\n   * Manually closes the WebSocket connection.\n   */\n  public close(): void {\n    try {\n      if (this.ws) {\n        this.ws.close();\n        this.ws = undefined;\n        console.log(\"WebSocket connection closed\");\n      }\n    } catch (error) {\n      console.error(\"Error closing WebSocket:\",\n          error instanceof Error ? error.message : 'Unknown error'\n      );\n    }\n  }\n\n  /**\n   * Checks if the WebSocket is currently connected.\n   *\n   * @returns {boolean} True if connected, false otherwise\n   */\n  public isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Gets the current connection state.\n   *\n   * @returns {number} The WebSocket ready state\n   */\n  public getState(): number {\n    return this.ws?.readyState ?? WebSocket.CLOSED;\n  }\n}\n", "import { BaseClient } from \"./baseClient.js\";\nimport type {\n  AriClientConfig,\n  WebSocketEvent,\n  WebSocketEventType,\n} from \"./interfaces\";\nimport { Applications } from \"./resources/applications.js\";\nimport { Asterisk } from \"./resources/asterisk\";\nimport { Bridges } from \"./resources/bridges\";\nimport { type ChannelInstance, Channels } from \"./resources/channels.js\";\nimport { Endpoints } from \"./resources/endpoints\";\nimport { type PlaybackInstance, Playbacks } from \"./resources/playbacks\";\nimport { Sounds } from \"./resources/sounds\";\nimport { WebSocketClient } from \"./websocketClient.js\";\n\n/**\n * Main client class for interacting with the Asterisk REST Interface (ARI).\n * Provides access to various ARI resources and WebSocket event handling capabilities.\n *\n * @example\n * ```typescript\n * const client = new AriClient({\n *   host: 'localhost',\n *   port: 8088,\n *   username: 'user',\n *   password: 'secret'\n * });\n * ```\n */\nexport class AriClient {\n  private readonly baseClient: BaseClient;\n  private webSocketClient?: WebSocketClient;\n\n  public readonly channels: Channels;\n  public readonly endpoints: Endpoints;\n  public readonly applications: Applications;\n  public readonly playbacks: Playbacks;\n  public readonly sounds: Sounds;\n  public readonly asterisk: Asterisk;\n  public readonly bridges: Bridges;\n\n  /**\n   * Creates a new instance of the ARI client.\n   *\n   * @param {AriClientConfig} config - Configuration options for the ARI client\n   * @throws {Error} If required configuration parameters are missing\n   */\n  constructor(private readonly config: AriClientConfig) {\n    if (!config.host || !config.port || !config.username || !config.password) {\n      throw new Error(\"Missing required configuration parameters\");\n    }\n\n    // Normalize host and create base URL\n    const httpProtocol = config.secure ? \"https\" : \"http\";\n    const normalizedHost = config.host.replace(/^https?:\\/\\//, \"\");\n    const baseUrl = `${httpProtocol}://${normalizedHost}:${config.port}/ari`;\n\n    // Initialize base client and resources\n    this.baseClient = new BaseClient(baseUrl, config.username, config.password);\n\n    // Initialize resource handlers\n    this.channels = new Channels(this.baseClient, this);\n    this.playbacks = new Playbacks(this.baseClient, this);\n    this.endpoints = new Endpoints(this.baseClient);\n    this.applications = new Applications(this.baseClient);\n    this.sounds = new Sounds(this.baseClient);\n    this.asterisk = new Asterisk(this.baseClient);\n    this.bridges = new Bridges(this.baseClient);\n\n    console.log(`ARI Client initialized with base URL: ${baseUrl}`);\n  }\n\n  /**\n   * Initializes a WebSocket connection for receiving events.\n   *\n   * @param {string[]} apps - List of application names to subscribe to\n   * @param {WebSocketEventType[]} [subscribedEvents] - Optional list of specific event types to subscribe to\n   * @returns {Promise<void>} Resolves when connection is established\n   * @throws {Error} If connection fails or if WebSocket is already connected\n   */\n  public async connectWebSocket(\n      apps: string[],\n      subscribedEvents?: WebSocketEventType[],\n  ): Promise<void> {\n    if (!apps.length) {\n      throw new Error(\"At least one application name is required\");\n    }\n\n    if (this.webSocketClient) {\n      console.warn(\"WebSocket is already connected\");\n      return;\n    }\n\n    try {\n      this.webSocketClient = new WebSocketClient(\n          this.baseClient,\n          apps,\n          subscribedEvents,\n          this,\n      );\n      await this.webSocketClient.connect();\n      console.log(\"WebSocket connection established successfully\");\n    } catch (error) {\n      console.error(\"Failed to establish WebSocket connection:\", error);\n      this.webSocketClient = undefined;\n      throw error;\n    }\n  }\n\n  /**\n   * Registers an event listener for WebSocket events.\n   *\n   * @param {T} event - The event type to listen for\n   * @param {Function} listener - Callback function for handling the event\n   * @throws {Error} If WebSocket is not connected\n   */\n  public on<T extends WebSocketEvent[\"type\"]>(\n      event: T,\n      listener: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!this.webSocketClient) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n    this.webSocketClient.on(event, listener);\n    console.log(`Event listener registered for ${event}`);\n  }\n\n  /**\n   * Registers a one-time event listener for WebSocket events.\n   *\n   * @param {T} event - The event type to listen for\n   * @param {Function} listener - Callback function for handling the event\n   * @throws {Error} If WebSocket is not connected\n   */\n  public once<T extends WebSocketEvent[\"type\"]>(\n      event: T,\n      listener: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!this.webSocketClient) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n    this.webSocketClient.once(event, listener);\n    console.log(`One-time event listener registered for ${event}`);\n  }\n\n  /**\n   * Removes an event listener for WebSocket events.\n   *\n   * @param {T} event - The event type to remove listener for\n   * @param {Function} listener - The listener function to remove\n   */\n  public off<T extends WebSocketEvent[\"type\"]>(\n      event: T,\n      listener: (data: Extract<WebSocketEvent, { type: T }>) => void,\n  ): void {\n    if (!this.webSocketClient) {\n      console.warn(\"No WebSocket connection to remove listener from\");\n      return;\n    }\n    this.webSocketClient.off(event, listener);\n    console.log(`Event listener removed for ${event}`);\n  }\n\n  /**\n   * Closes the WebSocket connection if one exists.\n   */\n  public closeWebSocket(): void {\n    if (!this.webSocketClient) {\n      console.warn(\"No WebSocket connection to close\");\n      return;\n    }\n    this.webSocketClient.close();\n    this.webSocketClient = undefined;\n    console.log(\"WebSocket connection closed\");\n  }\n\n  /**\n   * Creates or retrieves a Channel instance.\n   *\n   * @param {string} [channelId] - Optional ID of an existing channel\n   * @returns {ChannelInstance} A new or existing channel instance\n   */\n  public Channel(channelId?: string): ChannelInstance {\n    return this.channels.Channel({ id: channelId });\n  }\n\n  /**\n   * Creates or retrieves a Playback instance.\n   *\n   * @param {string} [playbackId] - Optional ID of an existing playback\n   * @param {string} [_app] - Optional application name (deprecated)\n   * @returns {PlaybackInstance} A new or existing playback instance\n   */\n  public Playback(playbackId?: string, _app?: string): PlaybackInstance {\n    return this.playbacks.Playback({ id: playbackId });\n  }\n\n  /**\n   * Gets the current WebSocket connection status.\n   *\n   * @returns {boolean} True if WebSocket is connected, false otherwise\n   */\n  public isWebSocketConnected(): boolean {\n    return !!this.webSocketClient;\n  }\n}\n"],
  "mappings": "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",
  "names": ["exports", "exports", "exports", "exports", "Delay", "exports", "SkipFirstDelay", "exports", "AlwaysDelay", "exports", "exports", "backOff", "exports", "BackOff", "axios", "message", "import_axios", "import_crypto", "toQueryParams", "toQueryParams", "import_events", "import_axios", "getErrorMessage", "import_events", "WebSocket"]
}
